<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Generador de Atlas de Texturas</title>
  <link rel="stylesheet" href="assets/styles.css"/>
</head>
<body>
  <header class="page-header">
    <h1>Generador de Atlas de Texturas</h1>
  </header>

  <main class="container">
    <section class="controls card">
      <div class="control-group">
        <label for="resolution">Resolución</label>
        <select id="resolution" class="input">
          <option value="512">512x512</option>
          <option value="1024" selected>1024x1024</option>
          <option value="2048">2048x2048</option>
          <option value="4096">4096x4096</option>
        </select>
      </div>

      <!-- NUEVO: combo de presets de divisiones -->
      <div class="control-group">
        <label for="gridPreset">Divisiones (preset)</label>
        <select id="gridPreset" class="input">
          <option value="2x2" selected>2 × 2</option>
          <option value="3x3">3 × 3</option>
          <option value="4x4">4 × 4</option>
          <option value="5x5">5 × 5</option>
          <option value="6x6">6 × 6</option>
        </select>
      </div>

      <!-- Fondo del atlas -->
      <div class="control-group control-bg">
        <label>Fondo del atlas</label>
        <div class="swatches" id="bgSwatches" role="radiogroup" aria-label="Colores de fondo">
          <button class="swatch-btn" data-color="#ffffff" aria-checked="true" title="Blanco" style="--sw: #ffffff"></button>
          <button class="swatch-btn" data-color="#cccccc" title="Gris claro" style="--sw: #cccccc"></button>
          <button class="swatch-btn" data-color="#808080" title="Gris" style="--sw: #808080"></button>
          <button class="swatch-btn" data-color="#000000" title="Negro" style="--sw: #000000"></button>
          <button class="swatch-btn" data-color="#ff0000" title="Rojo" style="--sw: #ff0000"></button>
          <button class="swatch-btn" data-color="#00ff00" title="Verde" style="--sw: #00ff00"></button>
          <button class="swatch-btn" data-color="#0000ff" title="Azul" style="--sw: #0000ff"></button>

          <button class="chip" id="bgTransparent" data-transparent="true">Transparente</button>

          <!-- Chip multicolor que dispara el input nativo -->
          <div class="color-picker-wrap" title="Más colores">
            <button type="button" class="color-chip-gradient" aria-label="Elegir color"></button>
            <input type="color" id="bgColorPicker" value="#ffffff" class="color-input-native" />
          </div>
        </div>
      </div>

      <div class="control-actions">
        <button class="btn" onclick="updateAtlas()">Actualizar</button>
        <button class="btn btn-secondary" onclick="clearAtlas()">Limpiar</button>
      </div>
    </section>

    <section class="atlas-layout">
      <div class="atlas-canvas card">
        <div class="canvas-wrapper">
          <canvas id="atlasCanvas" width="1024" height="1024"></canvas>
          <canvas id="gridOverlay" class="grid-overlay" width="1024" height="1024"></canvas>
        </div>
        <div class="export-controls">
          <button class="btn" onclick="downloadAtlas()">Descargar Atlas</button>
        </div>
      </div>

      <aside class="image-panel card" id="imageListContainer">
        <div class="panel-header">
          <h3>Texturas</h3>
          <div class="file-input-container">
            <label for="fileInput" class="btn btn-ghost">Agregar Imágenes</label>
            <input type="file" id="fileInput" multiple accept="image/*"/>
          </div>
        </div>

        <div class="drop-zone" id="dropZone">Arrastra imágenes aquí o usa “Agregar Imágenes”</div>

        <div id="imageList" class="image-list"></div>
      </aside>
    </section>
  </main>

  <footer class="page-footer">
    <small>Hecho con ❤️ para tu flujo de trabajo</small>
  </footer>

  <script>
    // ===== Helpers globales =====
    function preventDefaults(e){ e.preventDefault(); e.stopPropagation(); }
    const supportsCreateImageBitmap = 'createImageBitmap' in window;

    class TextureAtlas {
      constructor() {
        // Canvases
        this.canvas = document.getElementById('atlasCanvas');
        this.ctx = this.canvas.getContext('2d', { alpha: true });
        this.gridCanvas = document.getElementById('gridOverlay');
        this.gridCtx = this.gridCanvas.getContext('2d', { alpha: true });

        // Estado
        this.images = [];
        this.gridX = 2;
        this.gridY = 2;
        this.resolution = 1024;

        // Fondo
        this.backgroundTransparent = false;
        this.backgroundColor = '#ffffff';

        // Drag interno
        this.highlightedSlot = null;
        this.isDragging = false;
        this.draggedImageIndex = -1;

        // Dibujo batched
        this.needsDrawAtlas = false;
        this.needsDrawGrid  = false;
        this._rafId = null;

        // Tamaño visual fijo y responsivo
        this.canvas.style.width = 'min(560px, 90vw)';
        this.canvas.style.height = 'min(560px, 90vw)';
        this.gridCanvas.style.width = this.canvas.style.width;
        this.gridCanvas.style.height = this.canvas.style.height;

        this.setupEventListeners();
        this.updateAtlas();
      }

      setupEventListeners() {
        // Controles
        document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileSelect(e));
        document.getElementById('resolution').addEventListener('change', (e) => this.updateResolution(e));
        document.getElementById('gridPreset').addEventListener('change', () => this.updateGridFromPreset());

        // Fondo: swatches/picker
        const swatchContainer = document.getElementById('bgSwatches');
        swatchContainer.addEventListener('click', (e) => {
          const btn = e.target.closest('.swatch-btn');
          const chip = e.target.closest('#bgTransparent');
          if (btn) {
            this.backgroundTransparent = false;
            this.backgroundColor = btn.dataset.color;
            document.getElementById('bgColorPicker').value = this.toHex(this.backgroundColor);
            this.updateSwatchUI(btn);
            this.scheduleDrawAtlas();
          } else if (chip) {
            this.backgroundTransparent = true;
            this.updateSwatchUI(chip);
            this.scheduleDrawAtlas();
          }
        });
        document.getElementById('bgColorPicker').addEventListener('input', (e) => {
          this.backgroundTransparent = false;
          this.backgroundColor = e.target.value;
          this.updateSwatchUI(e.target);
          this.scheduleDrawAtlas();
        });

        // Canvas: DnD desde lista/archivos
        this.canvas.addEventListener('dragover', (e) => this.handleCanvasDragOver(e));
        this.canvas.addEventListener('drop', (e) => this.handleCanvasDrop(e));
        this.canvas.addEventListener('dragleave', () => this.clearSlotHighlight());

        // Canvas: drag interno
        this.canvas.addEventListener('mousedown', (e) => this.handleCanvasMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e), { passive: true });
        this.canvas.addEventListener('mouseup', () => this.handleCanvasMouseUp(), { passive: true });
        this.canvas.addEventListener('mouseleave', () => this.handleCanvasMouseUp(), { passive: true });

        // Drag & drop en panel lateral
        const imageListContainer = document.getElementById('imageListContainer');
        const dropZone = document.getElementById('dropZone');
        ['dragenter','dragover','dragleave','drop'].forEach(ev=>{
          imageListContainer.addEventListener(ev, preventDefaults, false);
          dropZone.addEventListener(ev, preventDefaults, false);
        });
        ['dragenter','dragover'].forEach(ev=>{
          imageListContainer.addEventListener(ev, ()=> imageListContainer.classList.add('drag-over'));
          dropZone.addEventListener(ev, ()=>{
            dropZone.classList.add('drag-over');
            dropZone.textContent = 'Suelta las imágenes aquí';
          });
        });
        ['dragleave','drop'].forEach(ev=>{
          imageListContainer.addEventListener(ev, ()=> imageListContainer.classList.remove('drag-over'));
          dropZone.addEventListener(ev, ()=>{
            dropZone.classList.remove('drag-over');
            dropZone.textContent = 'Arrastra imágenes aquí o usa “Agregar Imágenes”';
          });
        });
        imageListContainer.addEventListener('drop', (e)=> this.handleDropFiles(e));
        dropZone.addEventListener('drop', (e)=> this.handleDropFiles(e));
      }

      // ===== Utilidades de UI =====
      toHex(color){
        if (color.startsWith('#')) return color;
        const m = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/i);
        if (!m) return '#ffffff';
        const [r,g,b] = m.slice(1).map(n=>parseInt(n,10));
        return '#' + [r,g,b].map(v=>v.toString(16).padStart(2,'0')).join('');
      }
      updateSwatchUI(activeEl){
        document.querySelectorAll('.swatch-btn').forEach(b=>b.setAttribute('aria-checked','false'));
        document.getElementById('bgTransparent').classList.remove('active');
        if (activeEl.classList && activeEl.classList.contains('swatch-btn')){
          activeEl.setAttribute('aria-checked','true');
        }
        if (activeEl.id === 'bgTransparent'){
          activeEl.classList.add('active');
        }
      }

      // ===== Carga de archivos =====
      async loadImageFile(file) {
        try{
          let imgEl;
          if (supportsCreateImageBitmap) {
            const bmp = await createImageBitmap(file);
            const off = document.createElement('canvas');
            off.width = bmp.width; off.height = bmp.height;
            off.getContext('2d').drawImage(bmp, 0, 0);
            imgEl = new Image();
            imgEl.src = off.toDataURL(); // mantiene el resto del flujo
          } else {
            imgEl = new Image();
            imgEl.src = URL.createObjectURL(file);
            await new Promise(res=> imgEl.onload = res);
            URL.revokeObjectURL(imgEl.src);
          }
          this.images.push({ img: imgEl, name: file.name, gridX: -1, gridY: -1, assigned: false });
          this.updateImageList();
          this.scheduleDrawAtlas();
        }catch(e){
          console.error('Error cargando imagen:', e);
        }
      }
      handleDropFiles(event) {
        const files = Array.from(event.dataTransfer.files).filter(f=>f.type.startsWith('image/'));
        files.forEach(f => this.loadImageFile(f));
      }
      handleFileSelect(event) {
        const files = Array.from(event.target.files);
        files.forEach(f => this.loadImageFile(f));
        event.target.value = '';
      }

      // ===== Config =====
      updateResolution(event) {
        this.resolution = parseInt(event.target.value);
        this.canvas.width = this.resolution;
        this.canvas.height = this.resolution;
        this.gridCanvas.width = this.resolution;
        this.gridCanvas.height = this.resolution;
        this.scheduleDrawGrid();
        this.scheduleDrawAtlas();
      }

      // NUEVO: setear grid desde el combo
      updateGridFromPreset() {
        const val = document.getElementById('gridPreset').value; // ej. "4x4"
        const [gx, gy] = val.split('x').map(n => parseInt(n, 10));
        this.gridX = gx;
        this.gridY = gy;
        this.scheduleDrawGrid();
        this.scheduleDrawAtlas();
      }

      updateAtlas() {
        this.scheduleDrawGrid();
        this.scheduleDrawAtlas();
      }

      // ===== Dibujo batched =====
      scheduleDrawGrid(){ this.needsDrawGrid = true; this.requestFrame(); }
      scheduleDrawAtlas(){ this.needsDrawAtlas = true; this.requestFrame(); }
      requestFrame(){
        if (this._rafId !== null) return;
        this._rafId = requestAnimationFrame(()=> {
          this._rafId = null;
          if (this.needsDrawGrid){ this.drawGrid(); this.needsDrawGrid = false; }
          if (this.needsDrawAtlas){ this.drawAtlas(); this.needsDrawAtlas = false; }
        });
      }

      drawGrid() {
        const g = this.gridCtx;
        g.clearRect(0, 0, this.gridCanvas.width, this.gridCanvas.height);
        g.strokeStyle = '#ff4d4d';
        g.lineWidth = Math.max(2, this.resolution / 512);

        const cw = this.resolution / this.gridX;
        const ch = this.resolution / this.gridY;

        for (let i = 0; i <= this.gridX; i++) {
          const x = i * cw; g.beginPath(); g.moveTo(x, 0); g.lineTo(x, this.resolution); g.stroke();
        }
        for (let i = 0; i <= this.gridY; i++) {
          const y = i * ch; g.beginPath(); g.moveTo(0, y); g.lineTo(this.resolution, y); g.stroke();
        }
      }

      drawAtlas() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Fondo
        if (!this.backgroundTransparent) {
          ctx.fillStyle = this.backgroundColor || '#ffffff';
          ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        const cw = this.resolution / this.gridX;
        const ch = this.resolution / this.gridY;

        // Dibujar texturas
        for (let i=0;i<this.images.length;i++){
          const imgData = this.images[i];
          if (imgData.assigned && imgData.gridX >= 0 && imgData.gridY >= 0) {
            const x = imgData.gridX * cw;
            const y = imgData.gridY * ch;
            if (this.isDragging && i === this.draggedImageIndex) {
              ctx.strokeStyle = '#a0a0a0';
              ctx.setLineDash([5,5]);
              ctx.lineWidth = 2;
              ctx.strokeRect(x, y, cw, ch);
              ctx.setLineDash([]);
            } else {
              ctx.drawImage(imgData.img, x, y, cw, ch);
            }
          }
        }

        // Highlight
        if (this.highlightedSlot) {
          const x = this.highlightedSlot.gridX * cw;
          const y = this.highlightedSlot.gridY * ch;
          ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
          ctx.fillRect(x, y, cw, ch);
        }
      }

      // ===== Canvas DnD / drag interno =====
      handleCanvasDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
        const {gridX, gridY} = this.getGridFromEvent(event);
        if (this.validCell(gridX, gridY)) {
          this.highlightedSlot = { gridX, gridY };
          this.scheduleDrawAtlas();
        }
      }
      async handleCanvasDrop(event) {
        event.preventDefault();
        const files = Array.from(event.dataTransfer.files).filter(f=>f.type.startsWith('image/'));
        if (files.length > 0) {
          const {gridX, gridY} = this.getGridFromEvent(event);
          if (!this.validCell(gridX, gridY)) return;

          for (const file of files) {
            let imgEl;
            if (supportsCreateImageBitmap) {
              const bmp = await createImageBitmap(file);
              const off = document.createElement('canvas');
              off.width = bmp.width; off.height = bmp.height;
              off.getContext('2d').drawImage(bmp, 0, 0);
              imgEl = new Image();
              imgEl.src = off.toDataURL();
            } else {
              imgEl = new Image();
              imgEl.src = URL.createObjectURL(file);
              await new Promise(res=> imgEl.onload = res);
              URL.revokeObjectURL(imgEl.src);
            }

            const existing = this.images.findIndex(img => img.assigned && img.gridX === gridX && img.gridY === gridY);
            if (existing !== -1) {
              this.images[existing].assigned = false;
              this.images[existing].gridX = -1;
              this.images[existing].gridY = -1;
            }
            this.images.push({ img: imgEl, name: file.name, gridX, gridY, assigned: true });
            this.updateImageList();
            this.scheduleDrawAtlas();
          }
        } else {
          const imageIndex = parseInt(event.dataTransfer.getData('text/plain'));
          if (this.highlightedSlot && imageIndex >= 0) {
            const gx = this.highlightedSlot.gridX, gy = this.highlightedSlot.gridY;
            const existingIndex = this.images.findIndex(img => img.assigned && img.gridX === gx && img.gridY === gy);
            if (existingIndex !== -1) {
              this.images[existingIndex].assigned = false;
              this.images[existingIndex].gridX = -1;
              this.images[existingIndex].gridY = -1;
            }
            this.images[imageIndex].gridX = gx;
            this.images[imageIndex].gridY = gy;
            this.images[imageIndex].assigned = true;
          }
        }
        this.clearSlotHighlight();
        this.updateImageList();
        this.scheduleDrawAtlas();
      }

      handleCanvasMouseDown(event) {
        const {gridX, gridY} = this.getGridFromEvent(event);
        const idx = this.images.findIndex(img => img.assigned && img.gridX === gridX && img.gridY === gridY);
        if (idx !== -1) {
          this.isDragging = true;
          this.draggedImageIndex = idx;
          this.canvas.style.cursor = 'grabbing';
          this.scheduleDrawAtlas();
        }
      }
      handleCanvasMouseMove(event) {
        if (!this.isDragging) return;
        const {gridX, gridY} = this.getGridFromEvent(event);
        if (this.validCell(gridX, gridY)) {
          this.highlightedSlot = { gridX, gridY };
          this.scheduleDrawAtlas();
        } else {
          this.highlightedSlot = null;
          this.scheduleDrawAtlas();
        }
      }
      handleCanvasMouseUp() {
        if (this.isDragging && this.highlightedSlot && this.draggedImageIndex !== -1) {
          const dragged = this.images[this.draggedImageIndex];
          const {gridX, gridY} = this.highlightedSlot;

          const existingIndex = this.images.findIndex((img, i) =>
            img.assigned && img.gridX === gridX && img.gridY === gridY && i !== this.draggedImageIndex
          );
          if (existingIndex !== -1) {
            const existing = this.images[existingIndex];
            const tx = dragged.gridX, ty = dragged.gridY;
            dragged.gridX = existing.gridX; dragged.gridY = existing.gridY;
            existing.gridX = tx; existing.gridY = ty;
          } else {
            dragged.gridX = gridX; dragged.gridY = gridY;
          }
          this.updateImageList();
        }
        this.isDragging = false;
        this.draggedImageIndex = -1;
        this.canvas.style.cursor = 'grab';
        this.clearSlotHighlight();
      }

      clearSlotHighlight(){ this.highlightedSlot = null; this.scheduleDrawAtlas(); }
      validCell(gx, gy){ return gx>=0 && gy>=0 && gx<this.gridX && gy<this.gridY; }
      getGridFromEvent(event){
        const rect = this.canvas.getBoundingClientRect();
        const scaleX = this.resolution / rect.width;
        const scaleY = this.resolution / rect.height;
        const x = (event.clientX - rect.left) * scaleX;
        const y = (event.clientY - rect.top) * scaleY;
        const cw = this.resolution / this.gridX;
        const ch = this.resolution / this.gridY;
        return { gridX: Math.floor(x / cw), gridY: Math.floor(y / ch) };
      }

      // ===== Lista lateral =====
      updateImageList() {
        const list = document.getElementById('imageList');
        list.innerHTML = '';
        this.images.forEach((imageData, index) => {
          const item = document.createElement('div');
          item.className = 'image-item';
          item.draggable = true;
          if (!imageData.assigned) item.classList.add('unassigned');
          item.innerHTML = `
            <img src="${imageData.img.src}" class="image-preview" alt="${imageData.name}">
            <div class="image-info">
              <div class="image-name">${imageData.name}</div>
              <div class="image-size">${imageData.assigned ? `Slot: ${imageData.gridX}, ${imageData.gridY}` : 'Sin asignar'}</div>
            </div>
            <button class="remove-btn" aria-label="Eliminar" onclick="atlas.removeImage(${index})">✕</button>
          `;
          item.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData('text/plain', index.toString());
            item.classList.add('dragging');
          });
          item.addEventListener('dragend', () => item.classList.remove('dragging'));
          item.addEventListener('dblclick', () => {
            if (imageData.assigned) {
              imageData.assigned = false; imageData.gridX = -1; imageData.gridY = -1;
              this.updateImageList(); this.scheduleDrawAtlas();
            }
          });
          list.appendChild(item);
        });
      }

      // ===== Acciones =====
      removeImage(index) {
        this.images.splice(index, 1);
        this.updateImageList();
        this.scheduleDrawAtlas();
      }
      clearAtlas() {
        this.images = [];
        this.updateImageList();
        this.scheduleDrawAtlas();
      }
      downloadAtlas() {
        const link = document.createElement('a');
        link.download = `atlas_${this.gridX}x${this.gridY}_${this.resolution}.png`;
        link.href = this.canvas.toDataURL();
        link.click();
      }
      exportUV() {
        const uvData = this.images
          .filter(img => img.assigned)
          .map((img) => {
            const u = img.gridX / this.gridX;
            const v = img.gridY / this.gridY;
            const uWidth = 1.0 / this.gridX;
            const vHeight = 1.0 / this.gridY;
            return { name: img.name, gridX: img.gridX, gridY: img.gridY, u, v, uWidth, vHeight, uMax: u + uWidth, vMax: v + vHeight };
          });
        const blob = new Blob([JSON.stringify(uvData, null, 2)], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url; link.download = `uv_coordinates_${this.gridX}x${this.gridY}.json`;
        link.click();
        URL.revokeObjectURL(url);
      }
    }

    // Init
    const atlas = new TextureAtlas();

    // Botones globales usados por los atributos onclick
    function updateAtlas(){ atlas.updateAtlas(); }
    function clearAtlas(){ atlas.clearAtlas(); }
    function downloadAtlas(){ atlas.downloadAtlas(); }
    function exportUV(){ atlas.exportUV(); }
  </script>
</body>
</html>
